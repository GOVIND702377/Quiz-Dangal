name: AI Orchestrator - Report & Notify

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  contents: read

jobs:
  run-and-report:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      FUNCTION_URL: ${{ secrets.SUPABASE_URL }}/functions/v1/ai-orchestrator?limit=2
      CRON_SECRET: ${{ secrets.CRON_SECRET }}
      ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
    steps:
      - name: Validate secrets
        run: |
          if [ -z "$CRON_SECRET" ] || [ -z "$SUPABASE_URL" ] || [ -z "$ANON_KEY" ]; then
            echo "Missing required secrets (CRON_SECRET, SUPABASE_URL, SUPABASE_ANON_KEY)" >&2
            exit 1
          fi

      - name: Call ai-orchestrator and capture response
        id: call
        run: |
          set -e
          http_code=$(curl -sS -o resp.json -w "%{http_code}" -X POST "$FUNCTION_URL" \
            --connect-timeout 8 --max-time 25 \
            -H "X-Cron-Secret: $CRON_SECRET" \
            -H "Authorization: Bearer $ANON_KEY" -H "apikey: $ANON_KEY" \
            -H "Content-Type: application/json" -d '{}')
          echo "http=$http_code" >> $GITHUB_OUTPUT
          echo "response<<EOF" >> $GITHUB_OUTPUT
          cat resp.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Parse and summarize
        id: sum
        run: |
          node -e '
          const fs=require("fs");
          let j={};
          try{j=JSON.parse(fs.readFileSync("resp.json","utf8"))}catch(e){}
          const s=j.summary||{attempted:0,completed:0,failed:0,completedJobs:[],failedJobs:[]};
          console.log(`attempted=${s.attempted}`);
          console.log(`completed=${s.completed}`);
          console.log(`failed=${s.failed}`);
          fs.writeFileSync("summary.txt", `Attempted: ${s.attempted}\nCompleted: ${s.completed}\nFailed: ${s.failed}\n`);
          if(Array.isArray(s.failedJobs)&&s.failedJobs.length){
            fs.appendFileSync("summary.txt", "\nFailed Jobs:\n"+s.failedJobs.map(f=>`- #${f.id} ${f.category} @ ${f.slot_start} -> ${f.error}`).join("\n")+"\n");
          }
          if(Array.isArray(s.completedJobs)&&s.completedJobs.length){
            fs.appendFileSync("summary.txt", "\nCompleted Jobs:\n"+s.completedJobs.map(c=>`- #${c.id} ${c.category} @ ${c.slot_start} -> quiz=${c.quiz_id} provider=${c.provider}`).join("\n")+"\n");
          }
          '
          echo "attempted=$(grep -Eo '^Attempted: [0-9]+' summary.txt | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "failed=$(grep -Eo '^Failed: [0-9]+' summary.txt | awk '{print $2}')" >> $GITHUB_OUTPUT

      - name: Add job summary
        run: |
          echo "### AI Orchestrator run" >> $GITHUB_STEP_SUMMARY
          echo "HTTP: ${{ steps.call.outputs.http }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '\n````\n' >> $GITHUB_STEP_SUMMARY
          cat summary.txt >> $GITHUB_STEP_SUMMARY
          echo '\n````\n' >> $GITHUB_STEP_SUMMARY

      - name: Fail build if there were failed jobs
        if: ${{ steps.sum.outputs.failed && steps.sum.outputs.failed != '0' }}
        run: |
          echo "Detected ${{ steps.sum.outputs.failed }} failed jobs" >&2
          exit 2

      - name: Create or update issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = `AI Orchestrator failures detected`;
            const body = `Automated run detected failures.\n\n` +
              `HTTP: ${context.payload?.http || ''}\n\n` +
              'Summary:\n' +
              '```\n' + require('fs').readFileSync('summary.txt','utf8') + '\n```\n' +
              `Run: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            // Search open issues with same title
            const { data: issues } = await github.rest.issues.listForRepo({ owner: context.repo.owner, repo: context.repo.repo, state: 'open', labels: 'ai-orchestrator' });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, body });
            } else {
              await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title, body, labels: ['ai-orchestrator'] });
            }
